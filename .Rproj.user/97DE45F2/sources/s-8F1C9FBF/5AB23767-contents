library(geepack)
library(statmod)
library(splines)
library(splines2)
library(SimDesign)
library(gridExtra)
library(ggplot2)
library(car)
library(pracma)
library(stringr)
library(mgcv)
library(lubridate)
library(forecast)

inDir = 'I:/TimeSeries'
seasDir = 'I:/Seasonal_Plots'
int = "Daily"

fileList = list.files(path=inDir,pattern=paste('*_',int,'.csv',sep=""),
                      full.names=TRUE,recursive=FALSE,
                      include.dirs=FALSE,no..=TRUE)
goodIdx = c(1,2,4,8,11,13:19)



for (i in goodIdx){  # for each species' file
  
  thisCT = data.frame(read.csv(fileList[i]))  # load file
  attribs = attributes(thisCT)  # find names of sites (all columns but first)
  sites = attribs$names[2:numel(attribs$names)]
  
  CTname = str_remove(fileList[i],paste(inDir,'/',sep="")) # get the species/CT name
  CTname = str_remove(CTname,paste('_',int,'.csv',sep=""))
  
  #dateVec = as.POSIXlt(thisCT$Date,tz="GMT",format="%d-%b-%Y")
  dateVec = as.Date(thisCT$Date,format="%d-%b-%Y")
  
  
  # if it doesn't already exist, create directory to save figures
  if (!dir.exists(paste(seasDir,'/',CTname,sep=""))){
    dir.create(paste(seasDir,'/',CTname,sep=""))
  }
  
  for (j in 1:numel(sites)){ # for each site
    
    thisSite = as.numeric(thisCT[,j+1]) # get presence data for this site
    pres = which(thisSite!=0)
    
    if (!numel(pres)==0){ # if there is any presence
      
      # plot presence to determine if it's worth modeling
      plot(dateVec,thisCT[,j+1],main=paste(CTname,'at',sites[j],sep=" "),
           ylab="# 5-min Bins w Presence")
      
      userVote = c()
      while (numel(userVote)==0){
        
        userVote = readline(prompt="Enter 1 to proceed with modeling, or 0 to skip to next deployment: ")
        
        if (!numel(userVote)==0 && userVote!=1 && userVote!=0){
          message('WARNING: Entry not allowed')
          userVote = c()
          
        }
        else if (numel(userVote)==0){
          message('WARNING: Entry not allowed')
        }
        
      }
      
      if (as.numeric(userVote)==1){ # if user says "yes" to modeling
       
        corr = acf(thisSite,lag.max=150,na.action=na.pass,plot=FALSE) 
        lagID = which(abs(corr$acf)<0.2) # determine lag at which autocorrelation is <0.2
        # itsVal = IntegralTimeScaleCalc(thisSite)
        numClust = length(thisSite)/(lagID[1]-1)
        if (numClust<length(thisSite)){
          clustID = rep(1:ceiling(numClust),each=lagID[1]) # create grouping vector for GEEGLM
          clustID = clustID[1:numel(thisSite)]
        } else {
          clustID = 1:length(thisSite)
        }
        
        
        noDat = which(is.na(thisSite)) # remove days with no presence data
        if (!numel(noDat) == 0) {
          thisSite = thisSite[-noDat]
          reducedDateVec = dateVec[-noDat]
          reducedClustID = clustID[-noDat]
          Jday = as.numeric(format(reducedDateVec, "%j"))
          # monthGroup = month(reducedDateVec) # find which month each day of data falls in
          yearGroup = year(reducedDateVec) # find which year each day of data falls in
        } else if (numel(noDat) == 0) {
          reducedDateVec = dateVec
          reducedClustID = clustID
          Jday = as.numeric(format(reducedDateVec, "%j"))
          # monthGroup = month(reducedDateVec) # find which month each day of data falls in
          yearGroup = year(reducedDateVec) # find which year each day of data falls in
        }
        
        if (j == 7) {
          # create variable coding for change of site at HAT
          hatSite = rep(2, length(reducedDateVec))
          hatAdates = which(reducedDateVec <= as.Date("06-Feb-2017", format =
                                                        "%d-%b-%Y"))
          hatSite[hatAdates] = 1
        }
        
        # account for leap day in 2016, shift Julian days by value of 1
        leapIdx = which(yearGroup==2016)
        Jday[leapIdx] = Jday[leapIdx]-1
        
        # round presence data back to integers so it's Poisson distributed again
        thisSite = round(thisSite)
        
        
        # Fit GAM
        if (j==7){
          JDayGAM = gam(thisSite~s(Jday,bs="cc",k=6)+as.factor(yearGroup)+as.factor(hatSite),
                        family=tw)
        } else {JDayGAM = gam(thisSite~s(Jday,bs="cc",k=6)+as.factor(yearGroup),
                      family=tw)}
        sinkName = paste(seasDir,'/',CTname,'/',sites[j],"_GAMSummary.txt",sep="")
        sink(sinkName)
        print(summary(JDayGAM))
        sink()
        
        # Plot GAM partial residuals
        saveName = paste(seasDir,'/',CTname,'/',sites[j],"_GAM.png",sep="")
        if (j==7){
          png(saveName,width=800,height=500)
        } else {
          png(saveName,width=800,height=400)
        }
        
        plot.gam(JDayGAM,all.terms=TRUE,pages=1,main=paste(CTname,'at',sites[j]))
        while (dev.cur()>1) {dev.off()}
        
        
        # Fit GEEGLM; previously used bs(Jday,knots=mean(Jday))
        if (j==7){
          modJday = geeglm(thisSite~mSpline(Jday,knots=c(120,250),Boundary.knots=c(1,365),periodic=T)
                           +as.factor(yearGroup)+as.factor(hatSite),
                           family=poisson(link="log"),
                           id=reducedClustID,
                           corstr="ar1")
        } else {
          modJday = geeglm(thisSite~mSpline(Jday,knots=c(120,250),Boundary.knots=c(1,365),periodic=T)
                           +as.factor(yearGroup),
                           family=poisson(link="log"),
                           id=reducedClustID,
                           corstr="ar1")
        }
        
        sinkName = paste(seasDir,'/',CTname,'/',sites[j],"_GEEGLMSummary.txt",sep="")
        sink(sinkName)
        print(summary(modJday))
        sink()
        
        # modMon = geeglm(thisSite~bs(monthGroup,knots=mean(monthGroup))+as.factor(yearGroup),
        #                  family=poisson(link="log"),
        #                  id=reducedClustID,
        #                  corstr="ar1")
        # summary(modMon)
        
        
        # Bootstrap GEEGLM parameter estimate confidence intervals
        JDayForPlotting<- seq(min(Jday), max(Jday), length=50)
        JDayBootstrapParameters<-rmvnorm(10000, coef(modJday), summary(modJday)$cov.unscaled)
        if (j==7){
          testJday<- glm(thisSite ~ bs(Jday,knots=mean(Jday))+
                           as.factor(yearGroup)+as.factor(hatSite),
                         family=poisson)
          Jx1<-model.matrix(testJday)[,2:3]%*%coef(modJday)[c(2:3)]
          Jx2<-model.matrix(testJday)[,c(1,4:6)]%*%coef(modJday)[c(1,4:6)]
          Jx3<-model.matrix(testJday)[,c(1,7)]%*%coef(modJday)[c(1,7)]
        } else {
          testJday<- glm(thisSite ~ bs(Jday,knots=mean(Jday))+
                           as.factor(yearGroup),
                         family=poisson)
          Jx1<-model.matrix(testJday)[,2:3]%*%coef(modJday)[c(2:3)]
          Jx2<-model.matrix(testJday)[,c(1,4:6)]%*%coef(modJday)[c(1,4:6)]
        }
        
        
        # MonthForPlotting<- seq(min(monthGroup), max(monthGroup), length=50)
        # MonBootstrapParameters<-rmvnorm(10000, coef(modMon), summary(modMon)$cov.unscaled)
        # testMon<- glm(thisSite ~ bs(monthGroup,knots=mean(monthGroup))+
        #                  as.factor(yearGroup),
        #                family=poisson)
        # Mx1<-model.matrix(testMon)[,2:5]%*%coef(modMon)[c(2:5)]
        # Mx2<-model.matrix(testMon)[,c(1,6:8)]%*%coef(modMon)[c(1,6:8)]
        
        YearBootstrapCoefs<- JDayBootstrapParameters[,c(1,4:6)]
        quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
        cisY<-apply(YearBootstrapCoefs, 2, quant.func)
        # cilY<-cis[1,]-mean(Jx2)-coef(modJday)[1]
        # ciuY<-cis[2,]-mean(Jx2)-coef(modJday)[1]
        
        if (j==7){
          hatSiteBootstrapCoefs<- JDayBootstrapParameters[,c(1,7)]
          quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
          cisH<-apply(hatSiteBootstrapCoefs, 2, quant.func)
        }
        
        
        # Plot GEEGLM partial residuals
        # Julian Day
        JDayBootstrapCoefs<- JDayBootstrapParameters[,2:3]
        # Basis<- bs(JDayForPlotting, knots=mean(Jday), Boundary.knots=range(Jday))
        Basis<- mSpline(JDayForPlotting,knots=c(120,250),Boundary.knots=c(1,365),periodic=T)
        RealFit<- Basis%*%coef(modJday)[c(2:3)]
        RealFitCenterJ<- RealFit-mean(Jx1)-coef(modJday)[1]
        JDayBootstrapFits<- Basis%*%t(JDayBootstrapCoefs)
        quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
        cis<-apply(JDayBootstrapFits, 1, quant.func)
        MinimumYlimJ<- min(cis-mean(Jx1)-coef(modJday)[1])
        MaximumYlimJ<- max(cis-mean(Jx1)-coef(modJday)[1])
        Jcil<-cis[1,]-mean(Jx1)-coef(modJday)[1]
        Jciu<-cis[2,]-mean(Jx1)-coef(modJday)[1]
        saveName = paste(seasDir,'/',CTname,'/',sites[j],"_GEEGLM_JDayPlot.png",sep="")
        # png(saveName,width=600,height=350)
        qplot(JDayForPlotting,RealFitCenterJ,xlab="Julian Day", ylab="s(Julian Day)",
              main=paste(CTname,'at',sites[j]),
              ylim=c(MinimumYlimJ, MaximumYlimJ),
              geom="line")+theme(axis.line = element_line(),
                                 panel.background=element_blank(),
                                 panel.grid.major=element_blank(),
                                 panel.grid.minor=element_blank())+geom_smooth(fill="grey",
                                                                               colour="black",
                                                                               aes(ymin=Jcil,ymax=Jciu),
                                                                               stat="identity")+geom_rug(aes(x = Jday, y=-10000))
        ggsave(saveName,device="png")
        while (dev.cur()>1) {dev.off()}
        
        # Month
        # MonBootstrapCoefs<- MonBootstrapParameters[,2:5]
        # Basis<- bs(MonthForPlotting, knots=mean(monthGroup), Boundary.knots=range(monthGroup))
        # RealFit<- Basis%*%coef(modMon)[c(2:5)]
        # RealFitCenterM<- RealFit-mean(Mx1)-coef(modMon)[1]
        # MonBootstrapFits<- Basis%*%t(MonBootstrapCoefs)
        # quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
        # cis<-apply(MonBootstrapFits, 1, quant.func)
        # MinimumYlimM<- min(cis-mean(Mx1)-coef(modMon)[1])
        # MaximumYlimM<- max(cis-mean(Mx1)-coef(modMon)[1])
        # Mcil<-cis[1,]-mean(Mx1)-coef(modMon)[1]
        # Mciu<-cis[2,]-mean(Mx1)-coef(modMon)[1]
        # plot2<-qplot(MonthForPlotting,RealFitCenterM,
        #              xlab="Month", ylab="s(Month)", 
        #              main="b",ylim=c(MinimumYlimM, MaximumYlimM),
        #              geom="line")+theme(axis.line = element_line(),
        #                                 panel.background=element_blank(),
        #                                 panel.grid.major=element_blank(),
        #                                 panel.grid.minor=element_blank())+geom_smooth(fill="grey",
        #                                                                               colour="black",
        #                                                                               aes(ymin=Mcil,ymax=Mciu),
        #                                                                               stat="identity")+geom_rug(aes(x = monthGroup, y=-10000))
        
        # Year
        # years = as.numeric(2016:2019)
        # yearCoefs = as.numeric(apply(YearBootstrapCoefs,2,mean))
        # plot(years,yearCoefs,type="p",pch=21,cex=1.5,col="black",bg="black")
        # 
        # yearDat = data.frame(as.factor(years),yearCoefs,cil=cisY[1,],ciu=cisY[2,])
        # j = ggplot(yearDat,aes(x=years,y=yearCoefs,ymin=cil,ymax=ciu))
        # j + geom_linerange(data.frame(modJday$coefficients[c(1,6:8)]),
        #                    ymin=cis[1,],ymax=cis[2,])
        
        # AdjustedYearCoefs = data.frame(YearBootstrapCoefs[,1],
        #                                YearBootstrapCoefs[,2]+mean(YearBootstrapCoefs[,1]),
        #                                YearBootstrapCoefs[,3]+mean(YearBootstrapCoefs[,1]),
        #                                YearBootstrapCoefs[,4]+mean(YearBootstrapCoefs[,1]))
        # Center 
        AdjustedYearCoefs = data.frame(YearBootstrapCoefs[,1]-mean(YearBootstrapCoefs[,1]),
                                       YearBootstrapCoefs[,2],
                                       YearBootstrapCoefs[,3],
                                       YearBootstrapCoefs[,4])
        colnames(AdjustedYearCoefs) = c("2016","2017","2018","2019")
        # AdjustedYearCoefs = apply(AdjustedYearCoefs,2,exp) return to units of response var?
        
        
        saveName = paste(seasDir,'/',CTname,'/',sites[j],"_GEEGLM_YearPlot.png",sep="")
        png(saveName,width=500,height=400)
        boxplot(AdjustedYearCoefs,main=paste(CTname,'at',sites[j]),outline=FALSE,
                ylab=c("Year Coefficients"))
        #grid.arrange(plot1,plot2,ncol=1,nrow=2)
        while (dev.cur()>1) {dev.off()}
        
        if (j==7){
          AdjustedHATCoefs = data.frame(hatSiteBootstrapCoefs[,1],
                                        hatSiteBootstrapCoefs[,2]+mean(hatSiteBootstrapCoefs[,1]))
          colnames(AdjustedHATCoefs) = c("HAT_A","HAT_B")
          # AdjustedYearCoefs = apply(AdjustedYearCoefs,2,exp) return to units of response var?
          
          
          saveName = paste(seasDir,'/',CTname,'/',sites[j],"_GEEGLM_HATSitePlot.png",sep="")
          png(saveName,width=500,height=400)
          boxplot(AdjustedHATCoefs,main=paste(CTname,'at',sites[j]),outline=FALSE,
                  ylab=c("HAT Site Coefficients"))
          #grid.arrange(plot1,plot2,ncol=1,nrow=2)
          while (dev.cur()>1) {dev.off()}
          
        }
      }
      
    }
    
  }
}
