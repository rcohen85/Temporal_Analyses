library(SimDesign)
library(pracma)
library(mgcv)
library(car)
library(corrplot)
library(scales)
library(patchwork)
source("getPvalues.r")
#library(statmod)
#library(splines)
#library(forecast)
#library(car)
modelDFDir = 'I:/TimeSeries_ScaledByEffortError'
outDir = 'I:/ModelOutput'
int = "5minBin"
dfList = list.files(path=modelDFDir,pattern=paste('*Master.csv',sep=""),
full.names=TRUE,recursive=FALSE,
include.dirs=FALSE,no..=TRUE)
species = list.dirs(outDir,recursive=FALSE)
modFiles = list.files(path=species[i],pattern="*Model.Rdata",
full.names=TRUE,recursive=FALSE,include.dirs=FALSE,no..=TRUE)
CTname = str_remove(species[i],paste(outDir,'/',sep=""))
sites = list()
site = str_remove(modFiles[j],paste(outDir,"/",CTname,"/",sep=""))
sites = c(sites,str_remove(site,"_5minBin_Model.Rdata"))
load(modFiles[j]) # load model
# find associated master dataframe
thisSpec = which(str_detect(dfList,CTname))
thisSite = which(str_detect(dfList,unlist(sites[j])))
thisModInd = intersect(thisSpec,thisSite)
thisSite = data.frame(read.csv(dfList[thisModInd]))
# Get indices of coefficients for each covar
if (numel(JDKnots)==2){
JDind = c(2,3)
} else {JDind = c(2:4)}
if (numel(LunKnots)==2){
LunInd = JDind[length(JDind)]+c(1:5)
} else if (numel(LunKnots)==3){
LunInd = JDind[length(JDind)]+c(1:6)
}
YrInd = c(1,LunInd[length(LunInd)]+c(1:2))
#PhsInd = c(1,YrInd[length(YrInd)]+c(1:3))
BootstrapParameters<-rmvnorm(10000, coef(tempMod), summary(tempMod)$cov.unscaled)
JDayBootstrapCoefs<- BootstrapParameters[,JDind]
LunBootstrapCoefs<- BootstrapParameters[,LunInd]
YearBootstrapCoefs<- BootstrapParameters[,YrInd]
# PhsBootstrapCoefs<- BootstrapParameters[,PhsInd]
# if (j==7){ # if HAT, get coefficients for Site
#   hatSiteBootstrapCoefs<- BootstrapParameters[,c(1,7)]
#   quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
#   cisH<-apply(hatSiteBootstrapCoefs, 2, quant.func)
# }
# Predict presence at each X value using model coefficients
# if (j==7){ # if HAT, include Site as factor
#   JxJD<-model.matrix(tempMod)[,2:3]%*%coef(tempMod)[c(2:3)]
#   Jx2<-model.matrix(tempMod)[,c(1,4:6)]%*%coef(tempMod)[c(1,4:6)]
#   Jx3<-model.matrix(tempMod)[,c(1,7)]%*%coef(tempMod)[c(1,7)]
# } else {
JxJD = model.matrix(tempMod)[,JDind]%*%coef(tempMod)[JDind]
if (length(LunInd)>1){
JxLun = model.matrix(tempMod)[,LunInd]%*%coef(tempMod)[LunInd]
} else if (length(LunInd)==1){
JxLun = model.matrix(tempMod)[,LunInd]*coef(tempMod)[LunInd]
}
JxYr = model.matrix(tempMod)[,YrInd]%*%coef(tempMod)[YrInd]
# }
### Generate GEEGLM partial residual plots ---------------------------
## Julian Day ---------------------------
JDayForPlotting<- seq(min(thisSite$JulianDay), max(thisSite$JulianDay), length=5000)
JBasis<- mSpline(JDayForPlotting,  # spline spanning range of X values
knots=quantile(thisSite$JulianDay, probs=JDKnots),
Boundary.knots=c(1,365),
periodic=T) # basis functions for smooth function
RealFitJ<- JBasis%*%coef(tempMod)[JDind] # multiply basis functions by model coefficients to get values of spline at each X
RealFitCenterJ<- RealFitJ-mean(JxJD)#-coef(tempMod)[1] # adjust offset
RealFitCenterJ<- inv.logit(RealFitJ)
JDayBootstrapFits<- JBasis%*%t(JDayBootstrapCoefs) # get spread of spline values at each X based on distributions of each coefficient
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cisJ<-apply(JDayBootstrapFits, 1, quant.func)-mean(JxJD) # confidence interval of smooth function estimate
J
# Jcil<-cisJ[1,]-mean(JxJD)-coef(tempMod)[1] # lowerCI bound
# Jciu<-cisJ[2,]-mean(JxJD)-coef(tempMod)[1] # upper CI bound
Jcil<-inv.logit(cisJ[1,]) # lowerCI bound
Jciu<-inv.logit(cisJ[2,]) # upper CI bound
JplotDF = data.frame(JDayForPlotting,RealFitCenterJ)
colnames(JplotDF) = c("Jday","Fit")
dJday = stats::density(thisSite$JulianDay,na.rm = TRUE,n=5000,from=1,to=365) # Calculate kernel density of Jday observations
Jdens = data.frame(c(dJday$x,rev(dJday$x)),c(dJday$y,rep(0,length(dJday$y))))
colnames(Jdens) = c("Day","Density")
Jdens$Density = rescale(Jdens$Density, to=c(0.95*min(Jcil),min(Jcil))) # rescale density to sit at bottom of y-axis
ggplot(JplotDF, aes(Jday, Fit),
# ) + geom_polygon(data=Jdens,
#                  aes(Day,Density),
#                  fill=4,
#                  alpha=0.2
) + geom_smooth(fill = "grey",
colour = "black",
aes(ymin=Jcil, ymax=1.05*Jciu),
stat ="identity"
) + labs(x = "Julian Day",
y = "s(Julian Day)",
#title = paste(CTname, 'at',site),
) + theme(axis.line = element_line(),
panel.background = element_blank()
)
j=2
site = str_remove(modFiles[j],paste(outDir,"/",CTname,"/",sep=""))
sites = c(sites,str_remove(site,"_5minBin_Model.Rdata"))
load(modFiles[j]) # load model
# find associated master dataframe
thisSpec = which(str_detect(dfList,CTname))
thisSite = which(str_detect(dfList,unlist(sites[j])))
thisModInd = intersect(thisSpec,thisSite)
thisSite = data.frame(read.csv(dfList[thisModInd]))
# Get indices of coefficients for each covar
if (numel(JDKnots)==2){
JDind = c(2,3)
} else {JDind = c(2:4)}
if (numel(LunKnots)==2){
LunInd = JDind[length(JDind)]+c(1:5)
} else if (numel(LunKnots)==3){
LunInd = JDind[length(JDind)]+c(1:6)
}
YrInd = c(1,LunInd[length(LunInd)]+c(1:2))
#PhsInd = c(1,YrInd[length(YrInd)]+c(1:3))
## Bootstrap GEEGLM parameter estimates for later construction of confidence intervals ----------------
BootstrapParameters<-rmvnorm(10000, coef(tempMod), summary(tempMod)$cov.unscaled)
JDayBootstrapCoefs<- BootstrapParameters[,JDind]
LunBootstrapCoefs<- BootstrapParameters[,LunInd]
YearBootstrapCoefs<- BootstrapParameters[,YrInd]
# PhsBootstrapCoefs<- BootstrapParameters[,PhsInd]
# if (j==7){ # if HAT, get coefficients for Site
#   hatSiteBootstrapCoefs<- BootstrapParameters[,c(1,7)]
#   quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
#   cisH<-apply(hatSiteBootstrapCoefs, 2, quant.func)
# }
# Predict presence at each X value using model coefficients
# if (j==7){ # if HAT, include Site as factor
#   JxJD<-model.matrix(tempMod)[,2:3]%*%coef(tempMod)[c(2:3)]
#   Jx2<-model.matrix(tempMod)[,c(1,4:6)]%*%coef(tempMod)[c(1,4:6)]
#   Jx3<-model.matrix(tempMod)[,c(1,7)]%*%coef(tempMod)[c(1,7)]
# } else {
JxJD = model.matrix(tempMod)[,JDind]%*%coef(tempMod)[JDind]
if (length(LunInd)>1){
JxLun = model.matrix(tempMod)[,LunInd]%*%coef(tempMod)[LunInd]
} else if (length(LunInd)==1){
JxLun = model.matrix(tempMod)[,LunInd]*coef(tempMod)[LunInd]
}
JxYr = model.matrix(tempMod)[,YrInd]%*%coef(tempMod)[YrInd]
# }
### Generate GEEGLM partial residual plots ---------------------------
## Julian Day ---------------------------
JDayForPlotting<- seq(min(thisSite$JulianDay), max(thisSite$JulianDay), length=5000)
JBasis<- mSpline(JDayForPlotting,  # spline spanning range of X values
knots=quantile(thisSite$JulianDay, probs=JDKnots),
Boundary.knots=c(1,365),
periodic=T) # basis functions for smooth function
RealFitJ<- JBasis%*%coef(tempMod)[JDind] # multiply basis functions by model coefficients to get values of spline at each X
RealFitCenterJ<- RealFitJ-mean(JxJD)#-coef(tempMod)[1] # adjust offset
RealFitCenterJ<- inv.logit(RealFitJ)
JDayBootstrapFits<- JBasis%*%t(JDayBootstrapCoefs) # get spread of spline values at each X based on distributions of each coefficient
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cisJ<-apply(JDayBootstrapFits, 1, quant.func)-mean(JxJD) # confidence interval of smooth function estimate
# Jcil<-cisJ[1,]-mean(JxJD)-coef(tempMod)[1] # lowerCI bound
# Jciu<-cisJ[2,]-mean(JxJD)-coef(tempMod)[1] # upper CI bound
Jcil<-inv.logit(cisJ[1,]) # lowerCI bound
Jciu<-inv.logit(cisJ[2,]) # upper CI bound
JplotDF = data.frame(JDayForPlotting,RealFitCenterJ)
colnames(JplotDF) = c("Jday","Fit")
dJday = stats::density(thisSite$JulianDay,na.rm = TRUE,n=5000,from=1,to=365) # Calculate kernel density of Jday observations
Jdens = data.frame(c(dJday$x,rev(dJday$x)),c(dJday$y,rep(0,length(dJday$y))))
colnames(Jdens) = c("Day","Density")
Jdens$Density = rescale(Jdens$Density, to=c(0.95*min(Jcil),min(Jcil))) # rescale density to sit at bottom of y-axis
ggplot(JplotDF, aes(Jday, Fit),
# ) + geom_polygon(data=Jdens,
#                  aes(Day,Density),
#                  fill=4,
#                  alpha=0.2
) + geom_smooth(fill = "grey",
colour = "black",
aes(ymin=Jcil, ymax=1.05*Jciu),
stat ="identity"
) + labs(x = "Julian Day",
y = "s(Julian Day)",
#title = paste(CTname, 'at',site),
) + theme(axis.line = element_line(),
panel.background = element_blank()
)
JDayForPlotting<- seq(min(thisSite$JulianDay), max(thisSite$JulianDay), length=256)
JBasis<- mSpline(JDayForPlotting,  # spline spanning range of X values
knots=quantile(thisSite$JulianDay, probs=JDKnots),
Boundary.knots=c(1,365),
periodic=T) # basis functions for smooth function
RealFitJ<- JBasis%*%coef(tempMod)[JDind] # multiply basis functions by model coefficients to get values of spline at each X
RealFitCenterJ<- RealFitJ-mean(JxJD)#-coef(tempMod)[1] # adjust offset
RealFitCenterJ<- inv.logit(RealFitJ)
JDayBootstrapFits<- JBasis%*%t(JDayBootstrapCoefs) # get spread of spline values at each X based on distributions of each coefficient
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cisJ<-apply(JDayBootstrapFits, 1, quant.func)-mean(JxJD) # confidence interval of smooth function estimate
# Jcil<-cisJ[1,]-mean(JxJD)-coef(tempMod)[1] # lowerCI bound
# Jciu<-cisJ[2,]-mean(JxJD)-coef(tempMod)[1] # upper CI bound
Jcil<-inv.logit(cisJ[1,]) # lowerCI bound
Jciu<-inv.logit(cisJ[2,]) # upper CI bound
ggplot(JplotDF, aes(Jday, Fit),
# ) + geom_polygon(data=Jdens,
#                  aes(Day,Density),
#                  fill=4,
#                  alpha=0.2
) + geom_smooth(fill = "grey",
colour = "black",
aes(ymin=Jcil, ymax=1.05*Jciu),
stat ="identity"
) + labs(x = "Julian Day",
y = "s(Julian Day)",
#title = paste(CTname, 'at',site),
) + theme(axis.line = element_line(),
panel.background = element_blank()
)
### Generate GEEGLM partial residual plots ---------------------------
## Julian Day ---------------------------
JDayForPlotting<- seq(min(thisSite$JulianDay), max(thisSite$JulianDay), length=256)
JBasis<- mSpline(JDayForPlotting,  # spline spanning range of X values
knots=quantile(thisSite$JulianDay, probs=JDKnots),
Boundary.knots=c(1,365),
periodic=T) # basis functions for smooth function
RealFitJ<- JBasis%*%coef(tempMod)[JDind] # multiply basis functions by model coefficients to get values of spline at each X
RealFitCenterJ<- RealFitJ-mean(JxJD)#-coef(tempMod)[1] # adjust offset
RealFitCenterJ<- inv.logit(RealFitJ)
JDayBootstrapFits<- JBasis%*%t(JDayBootstrapCoefs) # get spread of spline values at each X based on distributions of each coefficient
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cisJ<-apply(JDayBootstrapFits, 1, quant.func)-mean(JxJD) # confidence interval of smooth function estimate
# Jcil<-cisJ[1,]-mean(JxJD)-coef(tempMod)[1] # lowerCI bound
# Jciu<-cisJ[2,]-mean(JxJD)-coef(tempMod)[1] # upper CI bound
Jcil<-inv.logit(cisJ[1,]) # lowerCI bound
Jciu<-inv.logit(cisJ[2,]) # upper CI bound
JplotDF = data.frame(JDayForPlotting,RealFitCenterJ)
colnames(JplotDF) = c("Jday","Fit")
ggplot(JplotDF, aes(Jday, Fit),
# ) + geom_polygon(data=Jdens,
#                  aes(Day,Density),
#                  fill=4,
#                  alpha=0.2
) + geom_smooth(fill = "grey",
colour = "black",
aes(ymin=Jcil, ymax=1.05*Jciu),
stat ="identity"
) + labs(x = "Julian Day",
y = "s(Julian Day)",
#title = paste(CTname, 'at',site),
) + theme(axis.line = element_line(),
panel.background = element_blank()
)
JDayForPlotting<- seq(min(thisSite$JulianDay), max(thisSite$JulianDay), length=256)
JBasis<- mSpline(JDayForPlotting,  # spline spanning range of X values
knots=quantile(thisSite$JulianDay, probs=JDKnots),
Boundary.knots=c(1,365),
periodic=T) # basis functions for smooth function
RealFitJ<- JBasis%*%coef(tempMod)[JDind] # multiply basis functions by model coefficients to get values of spline at each X
RealFitCenterJ<- RealFitJ-mean(JxJD)-coef(tempMod)[1] # adjust offset
# RealFitCenterJ<- inv.logit(RealFitJ)
JDayBootstrapFits<- JBasis%*%t(JDayBootstrapCoefs) # get spread of spline values at each X based on distributions of each coefficient
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cisJ<-apply(JDayBootstrapFits, 1, quant.func)-mean(JxJD) # confidence interval of smooth function estimate
Jcil<-cisJ[1,]-mean(JxJD)-coef(tempMod)[1] # lowerCI bound
Jciu<-cisJ[2,]-mean(JxJD)-coef(tempMod)[1] # upper CI bound
# Jcil<-inv.logit(cisJ[1,]) # lowerCI bound
# Jciu<-inv.logit(cisJ[2,]) # upper CI bound
JplotDF = data.frame(JDayForPlotting,RealFitCenterJ)
colnames(JplotDF) = c("Jday","Fit")
dJday = stats::density(thisSite$JulianDay,na.rm = TRUE,n=5000,from=1,to=365) # Calculate kernel density of Jday observations
Jdens = data.frame(c(dJday$x,rev(dJday$x)),c(dJday$y,rep(0,length(dJday$y))))
colnames(Jdens) = c("Day","Density")
Jdens$Density = rescale(Jdens$Density, to=c(0.95*min(Jcil),min(Jcil))) # rescale density to sit at bottom of y-axis
ggplot(JplotDF, aes(Jday, Fit),
# ) + geom_polygon(data=Jdens,
#                  aes(Day,Density),
#                  fill=4,
#                  alpha=0.2
) + geom_smooth(fill = "grey",
colour = "black",
aes(ymin=Jcil, ymax=1.05*Jciu),
stat ="identity"
) + labs(x = "Julian Day",
y = "s(Julian Day)",
#title = paste(CTname, 'at',site),
) + theme(axis.line = element_line(),
panel.background = element_blank()
)
modelFiles
modFiles
JDayForPlotting<- seq(min(thisSite$JulianDay), max(thisSite$JulianDay), length=256)
JBasis<- mSpline(JDayForPlotting,  # spline spanning range of X values
knots=quantile(thisSite$JulianDay, probs=JDKnots),
Boundary.knots=c(1,365),
periodic=T) # basis functions for smooth function
RealFitJ<- JBasis%*%coef(tempMod)[JDind] # multiply basis functions by model coefficients to get values of spline at each X
RealFitCenterJ<- RealFitJ-mean(JxJD)#-coef(tempMod)[1] # adjust offset
RealFitCenterJ<- inv.logit(RealFitJ)
JDayBootstrapFits<- JBasis%*%t(JDayBootstrapCoefs) # get spread of spline values at each X based on distributions of each coefficient
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cisJ<-apply(JDayBootstrapFits, 1, quant.func)-mean(JxJD) # confidence interval of smooth function estimate
# Jcil<-cisJ[1,]-mean(JxJD)-coef(tempMod)[1] # lowerCI bound
# Jciu<-cisJ[2,]-mean(JxJD)-coef(tempMod)[1] # upper CI bound
Jcil<-inv.logit(cisJ[1,]) # lowerCI bound
Jciu<-inv.logit(cisJ[2,]) # upper CI bound
JplotDF = data.frame(JDayForPlotting,RealFitCenterJ)
colnames(JplotDF) = c("Jday","Fit")
dJday = stats::density(thisSite$JulianDay,na.rm = TRUE,n=256,from=1,to=365) # Calculate kernel density of Jday observations
Jdens = data.frame(c(dJday$x,rev(dJday$x)),c(dJday$y,rep(0,length(dJday$y))))
colnames(Jdens) = c("Day","Density")
Jdens$Density = rescale(Jdens$Density, to=c(0.95*min(Jcil),min(Jcil))) # rescale density to sit at bottom of y-axis
ggplot(JplotDF, aes(Jday, Fit),
# ) + geom_polygon(data=Jdens,
#                  aes(Day,Density),
#                  fill=4,
#                  alpha=0.2
) + geom_smooth(fill = "grey",
colour = "black",
aes(ymin=Jcil, ymax=1.05*Jciu),
stat ="identity"
) + labs(x = "Julian Day",
y = "s(Julian Day)",
#title = paste(CTname, 'at',site),
) + theme(axis.line = element_line(),
panel.background = element_blank()
)
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
dateS[i]
which(dateS[i] >= global_expts$start)
View(global_expts)
which(global_expts$start >= dateS[i])
which(dateE[i] <= global_expts$end)
url
dateSubsetStarts
dateSubsetEnds
dateSubsetStarts[1]
dateSubsetEnds[length(dateSubsetEnds)]
dlSpecs
length(url)
dlSpecs
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
dateSubsetStarts
dateSubsetEnds
length(url)
url[j]
fileName
dateSubsetStarts[j]
sprintf('%s/HYCOM_%s_%.0f_%s_%s_%.0f.nc4',saveDir,
covars[l],vertLayers[vertCoord],dateSubsetStarts[j],dateSubsetEnds[j],j)
fileName = sprintf('%s/HYCOM_%s_%.0f_%s_%s_%.0f.nc4',saveDir,
covars[l],vertLayers[vertCoord],dateSubsetStarts[j],dateSubsetEnds[j],j)
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
url[j]
# Download the data
#download.file(url[j], fileName, quiet=FALSE)
return(sprintf('Downloading %s data from %s',covars[l],url[j]))
return(sprintf('Downloading %s data from %s',covars[l],url[j]))
# Download the data
#download.file(url[j], fileName, quiet=FALSE)
sprintf('Downloading %s data from %s',covars[l],url[j])
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
sprintf('%s/HYCOM_%s_%.0f_%s_%s_%.0f.nc4',saveDir,
covars[l],vertLayers[vertCoord],dateSubsetStarts[j],dateSubsetEnds[j],j)
sprintf('%s/HYCOM_%s_%.0f_%s_%s.nc4',saveDir,
covars[l],vertLayers[vertCoord],dateSubsetStarts[j],dateSubsetEnds[j])
source("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
View(global_expts)
source("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
source("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
vertCoord[m]
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
# Enter covariate(s) of interest
covars = c("water_temp","salinity")
# Enter regions of interest; "global" (1/12degree) OR "GoM" (1/25degree)
region <- c("global")
# Enter date range(s) of interest in pairs of start/end dates
dateS <- as.Date(c('2016-09-20','2017-01-01')) # start date(s)
dateE <- as.Date(c('2017-01-25','2017-02-10')) # end date(s)
# Enter study area boundaries in decimal degree lat/long limits
latS <- c(24) # southern bound(s)
latN <- c(46) # northern bound(s)
lonE <- c(-63) # eastern bound(s); use "-" for west of Prime Meridian
lonW <- c(-82) # western bound(s); use "-" for west of Prime Meridian
# SET AT LEAST ONE OF THESE TO NaN
vertCoord = c(1,20) # Enter vertical layer(s) to grab (e.g. 1 for 0.0m, see depths above) OR
vertStride = NaN # Enter vertical stride (1 for all depth layers, 2 for every other, etc.)
# Directory to save data; be sure to use forward slashes!
saveDir = "I:/DataScrapingCode/Test"
# Action -----------------------------------------
dir.create(file.path(saveDir), recursive = TRUE, showWarnings = FALSE)
setwd(saveDir)
# Base urls and data dates for each experiment; note these dates do not reflect the true start/end
# dates of the experiments, but are adjusted to eradicate temporal overlap between experiments
global_expts = data.frame(
url=c('http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/1994',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/1995',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/1996',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/1997',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/1998',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/1999',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2000',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2001',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2002',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2003',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2004',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2005',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2006',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2007',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2008',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2009',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2010',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2011',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2012',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2013',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_53.X/data/2014',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_56.3',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_57.2',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_92.8',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_57.7',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_92.9',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_93.0',
'http://ncss.hycom.org/thredds/ncss/GLBv0.08/expt_93.0'),
start=c(as.Date('1994-01-01'), as.Date('1995-01-01'), as.Date('1996-01-01'),
as.Date('1997-01-01'), as.Date('1998-01-01'), as.Date('1999-01-01'),
as.Date('2000-01-01'), as.Date('2001-01-01'), as.Date('2002-01-01'),
as.Date('2003-01-01'), as.Date('2004-01-01'), as.Date('2005-01-01'),
as.Date('2006-01-01'), as.Date('2007-01-01'), as.Date('2008-01-01'),
as.Date('2009-01-01'), as.Date('2010-01-01'), as.Date('2011-01-01'),
as.Date('2012-01-01'), as.Date('2013-01-01'), as.Date('2014-01-01'),
as.Date('2014-07-01'), as.Date('2016-10-01'), as.Date('2017-02-01'),
as.Date('2017-06-01'), as.Date('2017-10-01'), as.Date('2018-01-01'),
as.Date('2020-02-19')),
end=c(as.Date('1994-12-31'), as.Date('1995-12-31'), as.Date('1996-12-31'),
as.Date('1997-12-31'), as.Date('1998-12-31'), as.Date('1999-12-31'),
as.Date('2000-12-31'), as.Date('2001-12-31'), as.Date('2002-12-31'),
as.Date('2003-12-31'), as.Date('2004-12-31'), as.Date('2005-12-31'),
as.Date('2006-12-31'), as.Date('2007-12-31'), as.Date('2008-12-31'),
as.Date('2009-12-31'), as.Date('2010-12-31'), as.Date('2011-12-31'),
as.Date('2012-12-31'), as.Date('2013-12-31'), as.Date('2014-06-30'),
as.Date('2016-09-30'), as.Date('2017-01-31'), as.Date('2017-05-31'),
as.Date('2017-09-30'), as.Date('2017-12-31'), as.Date('2020-02-18'),
Sys.Date() - 2))
gom_expts = data.frame(
url=c('http://ncss.hycom.org/thredds/ncss/GOMu0.04/expt_50.1',
'http://ncss.hycom.org/thredds/ncss/GOMl0.04/expt_31.0',
'http://ncss.hycom.org/thredds/ncss/GOMl0.04/expt_32.5',
'http://ncss.hycom.org/thredds/ncss/GOMu0.04/expt_90.1m000'),
start=c(as.Date('1993-01-01'), as.Date('2013-01-01'), as.Date('2014-09-01'), as.Date('2019-01-01')),
end=c(as.Date('2012-12-31'), as.Date('2014-08-30'), as.Date('2018-12-31'), as.Date('2021-07-15')))
vertLayers = c(0.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 15.0, 20.0, 25.0, 30.0,
35.0, 40.0, 45.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 125.0, 150.0, 200.0, 250.0, 300.0, 350.0,
400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1250.0, 1500.0, 2000.0, 2500.0, 3000.0, 4000.0, 5000.0)
i=1
k=1
l=1
q <- which(dateS[i] >= global_expts$start)
r <- which(dateE[i] <= global_expts$end)
idxRange <- c(tail(q,1):r[1])
url <- global_expts$url[idxRange]
dateSubsetStarts <- global_expts$start[idxRange] # subset date ranges by experiment
dateSubsetEnds <- global_expts$end[idxRange]
dateSubsetStarts[1] <- dateS[i]
dateSubsetEnds[length(dateSubsetEnds)] <- dateE[i]
# Construct string containing relevant info on vars, region, period, etc.
dlSpecs <- '?'
# Add the variable
dlSpecs = sprintf('%svar=%s&', dlSpecs, covars[l])
# Add the spatial bounds
dlSpecs = sprintf('%snorth=%.4f&west=%.4f&east=%.4f&south=%.4f&disableProjSubset=on&horizStride=1&',
dlSpecs, latN[k], lonW[k], lonE[k], latS[k] )
!is.na(vertStride)
# Download associated lat-lon points
dlSpecs = sprintf('%saddLatLon=true&', dlSpecs)
# Get data in netcdf4 format
dlSpecs = sprintf('%saccept=netcdf4&', dlSpecs)
j=1
m=1
length(vertCoord)
!is.na(vertCoord)
any(!is.na(vertCoord))
dlSpecs = sprintf('%svertCoord=%s&', dlSpecs, vertCoord[m])
dlSpecs
vertlb = sprintf('vertLayer_%s',vertLayers[m])}
vertlb = sprintf('vertLayer_%s',vertLayers[m])
vertlb
# Add the time range(s) and construct download url(s)
url[j] <- paste(url[j],sprintf('%stime_start=%s%%3A00%%3A00Z&time_end=%s%%3A00%%3A00Z&timeStride=1',
dlSpecs, strftime(dateSubsetStarts[j], '%Y-%m-%dT00'),
strftime(dateSubsetEnds[j], '%Y-%m-%dT00')),sep='')
length(url)>1
fileName = sprintf('%s/HYCOM_%s_%d_%s_%s_%.0f.nc4',saveDir,
covars[l],vertlb,dateSubsetStarts[j],dateSubsetEnds[j],j)
fileName = sprintf('%s/HYCOM_%s_%d_%s_%s_%s.nc4',saveDir,
covars[l],vertlb,dateSubsetStarts[j],dateSubsetEnds[j],j)
covars[l]
vertlb
sprintf('%s/HYCOM_%s_%s_%s_%s_%s.nc4',saveDir,
covars[l],vertlb,dateSubsetStarts[j],dateSubsetEnds[j],j)
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
debugSource("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
source("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
source("D:/Code/MBARC_HabMod/extract_HYCOM_data.R")
library(curl)
library(pracma)
install.packages("ncdf4")
library(ncdf4)
updateR()
